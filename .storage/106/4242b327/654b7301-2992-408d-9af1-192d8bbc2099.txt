$ pwd
/data/chats/xpvnc/workspace/react_template
$ mkdir -p src/agent/tools/elasticsearch

$ cat > src/agent/tools/elasticsearch/ConsensusTool.js << 'EOL'
// src/agent/tools/elasticsearch/ConsensusTool.js

/**
 * ConsensusTool
 * 
 * Analyzes multiple generated query options, evaluates their quality,
 * and ranks them based on various criteria including precision, recall,
 * complexity, and performance implications.
 */
class ConsensusTool {
  constructor() {
    this.name = 'consensusAnalysis';
    this.description = 'Analyzes and ranks multiple query options to find the optimal approach';
  }

  /**
   * Execute the consensus analysis on multiple query options
   * 
   * @param {Object} params - Parameters for consensus analysis
   * @param {Array<Object>} params.queryOptions - Array of query options to evaluate
   * @param {Object} params.intent - The parsed user intent
   * @param {Object} params.schema - Schema information for context
   * @returns {Object} Ranked queries with explanations
   */
  async execute(params) {
    const { queryOptions = [], intent = {}, schema = {} } = params;
    
    if (!queryOptions || !Array.isArray(queryOptions) || queryOptions.length === 0) {
      throw new Error('No query options provided for analysis');
    }
    
    try {
      // Evaluate each query option
      const evaluatedQueries = queryOptions.map((option, index) => {
        const evaluation = this.evaluateQueryOption(option, intent, schema);
        return {
          id: `option_${index + 1}`,
          originalQuery: option,
          ...evaluation
        };
      });
      
      // Rank queries by overall score (descending)
      const rankedQueries = [...evaluatedQueries].sort((a, b) => {
        return b.overallScore - a.overallScore;
      });
      
      // Determine consensus approach and build response
      const result = {
        recommendedQuery: rankedQueries[0]?.originalQuery || null,
        recommendedQueryId: rankedQueries[0]?.id || null,
        evaluatedOptions: rankedQueries,
        consensusApproach: this.determineConsensusApproach(rankedQueries),
        reasoning: this.generateConsensusReasoning(rankedQueries),
        alternativeApproaches: this.extractAlternativeApproaches(rankedQueries)
      };
      
      return result;
    } catch (error) {
      console.error('Error in consensus analysis:', error);
      throw new Error(`Failed to analyze query options: ${error.message}`);
    }
  }
EOL

$ cat >> src/agent/tools/elasticsearch/ConsensusTool.js << 'EOL'
  
  /**
   * Evaluate a single query option against multiple criteria
   */
  evaluateQueryOption(query, intent, schema) {
    // Initialize scores for different dimensions
    const evaluation = {
      precision: this.evaluatePrecision(query, intent),
      recall: this.evaluateRecall(query, intent),
      complexity: this.evaluateComplexity(query),
      performance: this.evaluatePerformance(query, schema),
      schemaAlignment: this.evaluateSchemaAlignment(query, schema),
      strengths: [],
      weaknesses: [],
      explanation: ''
    };
    
    // Calculate overall score (weighted sum of dimensions)
    evaluation.overallScore = (
      evaluation.precision.score * 0.3 +
      evaluation.recall.score * 0.25 +
      evaluation.complexity.score * 0.15 +
      evaluation.performance.score * 0.2 +
      evaluation.schemaAlignment.score * 0.1
    );
    
    // Determine strengths and weaknesses
    this.determineStrengthsAndWeaknesses(evaluation);
    
    // Generate natural language explanation
    evaluation.explanation = this.generateExplanation(evaluation, intent);
    
    return evaluation;
  }
  
  /**
   * Evaluate the precision of a query (how specific and targeted it is)
   */
  evaluatePrecision(query, intent) {
    let score = 0.5; // Default middle score
    const reasons = [];
    
    // Check for field specificity
    if (this.hasSpecificFieldFilters(query)) {
      score += 0.2;
      reasons.push('Uses specific field filters that match the intent');
    } else {
      score -= 0.1;
      reasons.push('Uses overly broad field selection');
    }
    
    // Check for appropriate filtering
    if (this.hasAppropriateFiltering(query, intent)) {
      score += 0.2;
      reasons.push('Contains appropriate filtering conditions');
    } else {
      score -= 0.1;
      reasons.push('Missing important filtering conditions');
    }
    
    // Check for exact term usage when appropriate
    if (intent.exactMatching && this.usesExactMatching(query)) {
      score += 0.1;
      reasons.push('Correctly uses exact term matching');
    }
    
    // Cap the score between 0 and 1
    score = Math.max(0, Math.min(1, score));
    
    return {
      score,
      reasons
    };
  }
  
  /**
   * Evaluate the recall of a query (how comprehensive it is)
   */
  evaluateRecall(query, intent) {
    let score = 0.5; // Default middle score
    const reasons = [];
    
    // Check for appropriate use of wildcards/fuzzy matching
    if (intent.fuzzyMatching && this.usesFuzzyMatching(query)) {
      score += 0.2;
      reasons.push('Uses fuzzy matching to increase recall');
    }
    
    // Check for use of boolean OR or should clauses when appropriate
    if (intent.alternativeTerms && this.usesAlternatives(query)) {
      score += 0.2;
      reasons.push('Incorporates alternative terms or synonyms');
    } else if (intent.alternativeTerms) {
      score -= 0.1;
      reasons.push('Missing important alternative terms');
    }
    
    // Check for too many restrictive filters
    if (this.hasTooManyFilters(query)) {
      score -= 0.2;
      reasons.push('Contains too many restrictive filters that may exclude relevant results');
    }
    
    // Cap the score between 0 and 1
    score = Math.max(0, Math.min(1, score));
    
    return {
      score,
      reasons
    };
  }
EOL

