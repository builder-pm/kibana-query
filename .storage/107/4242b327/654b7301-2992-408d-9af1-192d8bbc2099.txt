$ pwd
/data/chats/xpvnc/workspace/react_template
$ mkdir -p src/agent/tools/elasticsearch

$ cat > src/agent/tools/elasticsearch/ConsensusTool.js << 'EOL'
// src/agent/tools/elasticsearch/ConsensusTool.js

/**
 * ConsensusTool
 * 
 * Analyzes multiple generated query options, evaluates their quality,
 * and ranks them based on various criteria including precision, recall,
 * complexity, and performance implications.
 */
class ConsensusTool {
  constructor() {
    this.name = 'consensusAnalysis';
    this.description = 'Analyzes and ranks multiple query options to find the optimal approach';
  }

  /**
   * Execute the consensus analysis on multiple query options
   * 
   * @param {Object} params - Parameters for consensus analysis
   * @param {Array<Object>} params.queryOptions - Array of query options to evaluate
   * @param {Object} params.intent - The parsed user intent
   * @param {Object} params.schema - Schema information for context
   * @returns {Object} Ranked queries with explanations
   */
  async execute(params) {
    const { queryOptions = [], intent = {}, schema = {} } = params;
    
    if (!queryOptions || !Array.isArray(queryOptions) || queryOptions.length === 0) {
      throw new Error('No query options provided for analysis');
    }
    
    try {
      // Evaluate each query option
      const evaluatedQueries = queryOptions.map((option, index) => {
        const evaluation = this.evaluateQueryOption(option, intent, schema);
        return {
          id: `option_${index + 1}`,
          originalQuery: option,
          ...evaluation
        };
      });
      
      // Rank queries by overall score (descending)
      const rankedQueries = [...evaluatedQueries].sort((a, b) => {
        return b.overallScore - a.overallScore;
      });
      
      // Determine consensus approach and build response
      const result = {
        recommendedQuery: rankedQueries[0]?.originalQuery || null,
        recommendedQueryId: rankedQueries[0]?.id || null,
        evaluatedOptions: rankedQueries,
        consensusApproach: this.determineConsensusApproach(rankedQueries),
        reasoning: this.generateConsensusReasoning(rankedQueries),
        alternativeApproaches: this.extractAlternativeApproaches(rankedQueries)
      };
      
      return result;
    } catch (error) {
      console.error('Error in consensus analysis:', error);
      throw new Error(`Failed to analyze query options: ${error.message}`);
    }
  }
EOL

$ cat >> src/agent/tools/elasticsearch/ConsensusTool.js << 'EOL'
  
  /**
   * Evaluate a single query option against multiple criteria
   */
  evaluateQueryOption(query, intent, schema) {
    // Initialize scores for different dimensions
    const evaluation = {
      precision: this.evaluatePrecision(query, intent),
      recall: this.evaluateRecall(query, intent),
      complexity: this.evaluateComplexity(query),
      performance: this.evaluatePerformance(query, schema),
      schemaAlignment: this.evaluateSchemaAlignment(query, schema),
      strengths: [],
      weaknesses: [],
      explanation: ''
    };
    
    // Calculate overall score (weighted sum of dimensions)
    evaluation.overallScore = (
      evaluation.precision.score * 0.3 +
      evaluation.recall.score * 0.25 +
      evaluation.complexity.score * 0.15 +
      evaluation.performance.score * 0.2 +
      evaluation.schemaAlignment.score * 0.1
    );
    
    // Determine strengths and weaknesses
    this.determineStrengthsAndWeaknesses(evaluation);
    
    // Generate natural language explanation
    evaluation.explanation = this.generateExplanation(evaluation, intent);
    
    return evaluation;
  }
  
  /**
   * Evaluate the precision of a query (how specific and targeted it is)
   */
  evaluatePrecision(query, intent) {
    let score = 0.5; // Default middle score
    const reasons = [];
    
    // Check for field specificity
    if (this.hasSpecificFieldFilters(query)) {
      score += 0.2;
      reasons.push('Uses specific field filters that match the intent');
    } else {
      score -= 0.1;
      reasons.push('Uses overly broad field selection');
    }
    
    // Check for appropriate filtering
    if (this.hasAppropriateFiltering(query, intent)) {
      score += 0.2;
      reasons.push('Contains appropriate filtering conditions');
    } else {
      score -= 0.1;
      reasons.push('Missing important filtering conditions');
    }
    
    // Check for exact term usage when appropriate
    if (intent.exactMatching && this.usesExactMatching(query)) {
      score += 0.1;
      reasons.push('Correctly uses exact term matching');
    }
    
    // Cap the score between 0 and 1
    score = Math.max(0, Math.min(1, score));
    
    return {
      score,
      reasons
    };
  }
  
  /**
   * Evaluate the recall of a query (how comprehensive it is)
   */
  evaluateRecall(query, intent) {
    let score = 0.5; // Default middle score
    const reasons = [];
    
    // Check for appropriate use of wildcards/fuzzy matching
    if (intent.fuzzyMatching && this.usesFuzzyMatching(query)) {
      score += 0.2;
      reasons.push('Uses fuzzy matching to increase recall');
    }
    
    // Check for use of boolean OR or should clauses when appropriate
    if (intent.alternativeTerms && this.usesAlternatives(query)) {
      score += 0.2;
      reasons.push('Incorporates alternative terms or synonyms');
    } else if (intent.alternativeTerms) {
      score -= 0.1;
      reasons.push('Missing important alternative terms');
    }
    
    // Check for too many restrictive filters
    if (this.hasTooManyFilters(query)) {
      score -= 0.2;
      reasons.push('Contains too many restrictive filters that may exclude relevant results');
    }
    
    // Cap the score between 0 and 1
    score = Math.max(0, Math.min(1, score));
    
    return {
      score,
      reasons
    };
  }
EOL

$ cat >> src/agent/tools/elasticsearch/ConsensusTool.js << 'EOL'
  
  /**
   * Evaluate the complexity of a query
   */
  evaluateComplexity(query) {
    let score = 1.0; // Start with perfect score and subtract for complexity
    const reasons = [];
    
    // Check nesting depth
    const nestingDepth = this.calculateQueryNestingDepth(query);
    if (nestingDepth > 3) {
      score -= 0.3;
      reasons.push(`Deep nesting (depth: ${nestingDepth}) adds unnecessary complexity`);
    } else if (nestingDepth > 2) {
      score -= 0.1;
      reasons.push('Moderate nesting depth');
    } else {
      reasons.push('Good query structure with appropriate nesting');
    }
    
    // Check boolean clause count
    const booleanClauseCount = this.countBooleanClauses(query);
    if (booleanClauseCount > 10) {
      score -= 0.3;
      reasons.push(`High number of boolean clauses (${booleanClauseCount})`);
    } else if (booleanClauseCount > 6) {
      score -= 0.15;
      reasons.push(`Moderate number of boolean clauses (${booleanClauseCount})`);
    } else {
      reasons.push('Appropriate number of boolean clauses');
    }
    
    // Check for unnecessary script usage
    if (this.hasScriptFiltering(query)) {
      score -= 0.2;
      reasons.push('Uses script filtering which could be replaced with simpler clauses');
    }
    
    // Cap the score between 0 and 1
    score = Math.max(0, Math.min(1, score));
    
    return {
      score,
      reasons
    };
  }
  
  /**
   * Evaluate potential performance implications of a query
   */
  evaluatePerformance(query, schema) {
    let score = 0.8; // Start with good score and adjust
    const reasons = [];
    
    // Check for wildcard prefix queries
    if (this.hasLeadingWildcards(query)) {
      score -= 0.3;
      reasons.push('Contains leading wildcards which can severely impact performance');
    }
    
    // Check for appropriate field usage based on schema
    if (this.usesNonIndexedFields(query, schema)) {
      score -= 0.2;
      reasons.push('References fields that may not be optimally indexed');
    }
    
    // Check for large result sets without pagination
    if (this.requestsLargeResults(query)) {
      score -= 0.2;
      reasons.push('Requests large result set without proper pagination');
    }
    
    // Check for fielddata on text fields
    if (this.usesFielddataOnText(query)) {
      score -= 0.2;
      reasons.push('Uses fielddata on text fields which can consume significant memory');
    }
    
    // Add bonus for queries that use filters instead of queries when appropriate
    if (this.usesFiltersAppropriately(query)) {
      score += 0.1;
      reasons.push('Appropriately uses filter context for cacheable clauses');
      // Cap at 1.0
      score = Math.min(1, score);
    }
    
    // Cap the score between 0 and 1
    score = Math.max(0, Math.min(1, score));
    
    return {
      score,
      reasons
    };
  }
  
  /**
   * Evaluate how well the query aligns with the provided schema
   */
  evaluateSchemaAlignment(query, schema) {
    let score = 0.7; // Start with decent score and adjust
    const reasons = [];
    
    // Skip detailed evaluation if no schema provided
    if (!schema || !schema.mappings || !schema.mappings.properties) {
      return {
        score: 0.5,
        reasons: ['Schema information not available for detailed evaluation']
      };
    }
    
    // Check if query uses fields that exist in schema
    const unknownFields = this.findUnknownFields(query, schema);
    if (unknownFields.length > 0) {
      score -= 0.2;
      reasons.push(`References fields not in schema: ${unknownFields.join(', ')}`);
    } else {
      score += 0.1;
      reasons.push('All referenced fields exist in schema');
    }
    
    // Check for appropriate query types based on field types
    const fieldTypeIssues = this.checkFieldTypeUsage(query, schema);
    if (fieldTypeIssues.length > 0) {
      score -= 0.2;
      reasons.push(...fieldTypeIssues);
    } else {
      score += 0.1;
      reasons.push('Query operations match field types');
    }
    
    // Cap the score between 0 and 1
    score = Math.max(0, Math.min(1, score));
    
    return {
      score,
      reasons
    };
  }
EOL

